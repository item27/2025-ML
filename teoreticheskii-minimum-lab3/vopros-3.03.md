# Вопрос №3.03

> Модель `dbscan`

DBSCAN — алгоритм плотностной кластеризации, который выделяет кластеры как области с высокой плотностью точек и помечает разрежённые области как шум.

## Идея

* Кластер — связная область, где у каждой «ядровой» точки достаточно соседей в радиусе $$\varepsilon$$.
* Нет необходимости задавать число кластеров заранее.
* Выделяет три типа точек: ядро, граничная, шум.

## Параметры

* $$\varepsilon$$ (eps) — радиус соседства.
*   $$\text{minPts}$$ — минимальное число точек в окрестности, чтобы точка считалась ядром. Условие ядра:

    $$
    |N_{\varepsilon}(p)| \ge \text{minPts},
    $$

    где $$N_{\varepsilon}(p)={q:, \mathrm{dist}(p,q)\le\varepsilon}$$.

## Классификация точек

* Ядровая: имеет минимум $$\text{minPts}$$ в $$\varepsilon$$-окрестности.
* Граничная: не ядро, но находится в $$\varepsilon$$-окрестности ядровой точки.
* Шум: ни в какой $$\varepsilon$$-окрестности нет достаточного числа точек.

## Связность по плотности

* Точка $$q$$ **directly density-reachable** от $$p$$, если $$q\in N_\varepsilon(p)$$ и $$p$$ — ядро.
* **Density-reachable** — транзитивное замыкание direct reachability.
* Кластеры — максимальные множества точек взаимно density-reachable через ядра.

## Алгоритм (в общих чертах)

1. Для каждой непомеченной точки $$p$$ найти $$N_\varepsilon(p)$$.
2. Если $$p$$ — ядро, начать новый кластер и рекурсивно добавить все density-reachable точки.
3. Если не ядро, пометить как шум или как граничную (возможно позже присоединится).

Псевдокод:

```
for each point p:
  if p not visited:
    mark visited
    neigh = regionQuery(p, eps)
    if |neigh| < minPts: mark p as noise
    else:
      C = new cluster
      expandCluster(p, neigh, C, eps, minPts)
```

## Сложность

* Без индекса: $$O(n^2)$$ (поиск соседей для каждой точки).
* С индексом (KD-tree, ball-tree) в низко/среднеразмерных задачах: примерно $$O(n \log n)$$.
* В больших размерностях индексы теряют эффективность.

## Преимущества

* Не требует заранее $$k$$.
* Выделяет шум.
* Находит кластеры произвольной формы (не только сферические).

## Недостатки и ограничения

* Плохо работает при разной плотности кластеров.
* Чувствителен к выбору $$\varepsilon$$ и $$\text{minPts}$$.
* В высоких размерностях расстояния концентрируются — выбор $$\varepsilon$$ затруднён.
* Индексы (KD-tree) деградируют при большой размерности.

## Как подбирать параметры

* Часто фиксируют $$\text{minPts}=2\cdot d$$ или $$\text{minPts}=4..10$$, где $$d$$ — число признаков.
* Строят $$k$$-dist plot: для каждого объекта считать расстояние до $$k$$-ого соседа, отсортировать и найти «локоть»; выбрать $$\varepsilon$$ в точке излома. Здесь $$k=\text{minPts}-1$$.
* Проверять чувствительность и визуализировать (если возможно).

## Практические советы

* Масштабировать признаки.
* В высоких размерностях сначала снизить размерность (PCA/UMAP).
* Для переменных плотностей использовать HDBSCAN.
* Для ускорения использовать пространственные индексы и/или реализацию на C/C++.

## Короткая шпаргалка для сдачи

* Параметры: $$\varepsilon$$ и $$\text{minPts}$$.
* Типы точек: ядро, граничная, шум.
* Хорош для кластеров произвольной формы и выделения шума.
* Не подходит для сильно различающейся плотности и очень высоких размерностей.
