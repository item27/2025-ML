# Вопрос №4.07

> Что такое рекуррентная ячейка (RNN), почему обрабатывает последовательности любой длины, сколько рекуррентных ячеек в рекуррентной сети, какие векторы принимает и возвращает

## Что такое рекуррентная ячейка

Рекуррентная ячейка — базовый блок RNN, который на каждом временном шаге обновляет своё скрытое состояние, используя новый вход и предыдущее состояние. Типичная формула для обычной RNN:

```
h_t = φ(W_x x_t + W_h h_{t-1} + b)
y_t = W_y h_t + c
```

где `φ` — нелинейность (tanh/ReLU), `x_t` — входной вектор в момент `t`, `h_{t-1}` — скрытое состояние с предыдущего шага, `h_t` — новое скрытое состояние, `y_t` — выход (не всегда используется).

## Почему работает с последовательностями любой длины

В каждой ячейке используются одни и те же веса (`W_x`, `W_h`). Сеть разворачивается по времени: для каждого токена мы повторно применяем ту же ячейку. Нет жёсткого ограничения на число шагов: пока есть входы, мы подаём их по одному и обновляем состояние. Поэтому RNN может обработать последовательность произвольной длины (ограничения только аппаратные/числовые).

## Сколько ячеек в рекуррентной сети

Фактически одна и та же ячейка (с одним набором весов) используется на всех позициях. При разворачивании говорят о «копиях» ячейки по числу временных шагов, но все они разделяют веса. Поэтому количество уникальных наборов параметров ≈ 1 (на слой). Если сеть многослойная (stacked RNN), на каждом слое своя ячейка.

## Какие векторы принимает и возвращает

* **Вход (`x_t`):** вектор признаков текущего токена. Обычно это эмбеддинг фиксированной длины `d_in`.
* **Предыдущее скрытое состояние (`h_{t-1}`):** вектор длины `d_h`, хранящий информацию о прошлых шагах.
* **Возвращает:**
  * Новое скрытое состояние `h_t` (используется на следующем шаге и/или передаётся вверх по сети).
  * Опционально выход `y_t` — если нужно предсказывать что-то на каждом шаге (классификация по токенам, генерация текста).

В простейшем RNN вход `x_t` и скрытое состояние `h_t` фиксированной размерности. Внутри не хранится полный список предыдущих токенов — только «сжатое» состояние, которое обновляется по рекуррентному правилу.
